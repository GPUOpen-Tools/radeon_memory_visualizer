//=============================================================================
// Copyright (c) 2019-2024 Advanced Micro Devices, Inc. All rights reserved.
/// @author AMD Developer Tools Team
/// @file
/// @brief  Data structures and functions to operate on a timeline.
//=============================================================================

#ifndef RMV_BACKEND_RMT_DATA_TIMELINE_H_
#define RMV_BACKEND_RMT_DATA_TIMELINE_H_

#include "rmt_types.h"
#include "rmt_error.h"
#include "rmt_configuration.h"
#include "rmt_segment_info.h"
#include "rmt_process_map.h"
#include "rmt_process_start_info.h"
#include "rmt_file_format.h"
#include "rmt_linear_buffer.h"

/// Scratch memory for the histogram calculation.
#define RMT_WODS_SCRATCH_SIZE (256)

/// The number of mip-map levels we want to support in the timeline.
#define RMT_MAXIMUM_TIMELINE_SERIES_LEVELS (20)

/// The maximum number of data series.
#define RMT_MAXIMUM_TIMELINE_DATA_SERIES (20)

#ifdef __cplusplus
extern "C" {
#endif  // #ifdef __cplusplus

typedef struct RmtDataSnapshot RmtDataSnapshot;
typedef struct RmtJobQueue     RmtJobQueue;
typedef struct RmtDataSet      RmtDataSet;

/// An enumeration of all timeline types that can be created. Specifies how to group the histogram into buckets.
typedef enum RmtDataTimelineType
{
    kRmtDataTimelineTypeProcess                  = 0,  ///< By which process owns it.
    kRmtDataTimelineTypePageSize                 = 1,  ///< Of page size used for the mapping.
    kRmtDataTimelineTypeCommitted                = 2,  ///< Of if the virtual address space is mapped to physical backing or not.
    kRmtDataTimelineTypeResourceUsageCount       = 3,  ///< Of resources where each bucket contains the number of that resource usage type.
    kRmtDataTimelineTypeResourceUsageVirtualSize = 4,  ///< Of resources where each bucket contains the size of that resource usage type in vm bytes.
    kRmtDataTimelineTypePaging                   = 5,  ///< Where each bucket is how much paging is happening (in bytes) for each physical heap type.
    kRmtDataTimelineTypeVirtualMemory            = 6,  ///< Where each bucket is how much virtual memory map is allocated for each preferred heap type.
    kRmtDataTimelineTypeResourceNonPreferred     = 7,  ///< Where each bucket is a resource usage type which is not its preferred heap.

    // add above this.
    kRmtDataTimelineTypeCount
} RmtDataTimelineType;

/// A structure encapsulating a single level in a series.
typedef struct RmtDataTimelineSeriesLevel
{
    uint64_t* values;       ///< Pointer to an array of <c><i>int32_t</i></c> values at this level in the series map.
    int32_t   value_count;  ///< The number of elements in the array pointed to by <c><i>values</i></c>.
} RmtDataTimelineSeriesLevel;

/// A structure encapsulating a single series.
///
/// A series is compromised of multiple levels of data. Each level is 50% the
/// size of the previous level, and is generated by taking the maximum value
/// seen in every two buckets of the previous level.
typedef struct RmtDataTimelineSeries
{
    RmtDataTimelineSeriesLevel levels[RMT_MAXIMUM_TIMELINE_SERIES_LEVELS];  ///< An array of <c><i>RmtDataTimelineSeriesLevel</i></c> structures.
    int32_t                    level_count;                                 ///< The number of elements used in <c><i>levels</i></c>.
} RmtDataTimelineSeries;

/// A structure encapsulating a timeline of a single RMT trace.
typedef struct RmtDataTimeline
{
    RmtDataSet* data_set;       ///< The <c><i>RmtDataSet</i></c> which this timeline was generated from.
    uint64_t    max_timestamp;  ///< The maximum timestamp seen in the data set.

    // The data for the currently selected timeline mode.
    RmtDataTimelineSeries series[RMT_MAXIMUM_TIMELINE_DATA_SERIES];  ///< An array of series of data.
    int32_t               series_count;                              ///< The number of elements used in <c><i>series</i></c>.
    int32_t*              series_memory_buffer;                      ///< The size of the series memory buffer. This is subdivided into the series and levels.
    uint64_t              maximum_value_in_all_series;               ///< The maxim value seen at any one time in all series.
    RmtDataTimelineType   timeline_type;                             ///< The type of timeline.
} RmtDataTimeline;

/// Destroy the timeline (and free underlaying memory allocated for this).
///
/// @param [in] timeline                                    A pointer to a <c><i>RmtDataTimeline</i></c> structure.
///
/// @retval
/// kRmtOk                                          The operation completed succesfully.
/// @retval
/// kRmtErrorInvalidPointer                         The operation failed because <c><i>timeline</i></c> was <c><i>NULL</i></c>.
/// @retval
/// kRmtErrorMalformedData                          The operation failed because <c><i>timeline</i></c> was not correctly initialized.
RmtErrorCode RmtDataTimelineDestroy(RmtDataTimeline* timeline);

/// A view of the timeline data according to certain view parameters.
typedef struct RmtDataTimelineHistogram
{
    const RmtDataTimeline* timeline;                               ///< A pointer to the <c><i>RmtDataTimeline</i></c> that was used to generate the histogram.
    uint64_t*              bucket_data;                            ///< A pointer to the memory allocated to contain the data.
    uint64_t               bucket_width_in_cycles;                 ///< The width of each bucket in cycles.
    int32_t                bucket_count;                           ///< The number of buckets.
    int32_t                bucket_group_count;                     ///< The number of groups that are inside each bucket.
    uint8_t                scratch_buffer[RMT_WODS_SCRATCH_SIZE];  ///< Scratch buffer used during calculations.
} RmtDataTimelineHistogram;

/// Create a <c><i>RmtDataTimelineHistogram</i></c>.
///
/// All parameters that are pointers do not transfer "ownership" of the
/// structures thereto pointed at. This means the client code is responsible
/// for ensuring that these objects are alive for for the duration of this
/// function's execution.
///
/// @param [in]  timeline                                   A pointer to a <c><i>RmtDataTimeline</i></c> structure to generate the <c><i>RmtDataTimelineHistogram</i></c> structure from.
/// @param [in]  job_queue                                  The job queue responsible for allocating work to worker threads.
/// @param [in]  bucket_count                               The number of buckets the new data set should contain.
/// @param [in]  bucket_width_in_rmt_cycles                 The width of each bucket, expressed in GPU cycles.
/// @param [in]  start_timestamp                            The starting timestamp.
/// @param [in]  end_timestamp                              The ending timestamp.
/// @param [out] out_timeline_histogram                     A pointer to a <c><i>RmtDataTimelineHistogram</i></c> structure to initialize.
///
/// @retval
/// kRmtOk                                          The operation completed successfully.
/// @retval
/// kRmtErrorInvalidPointer                         The operation failed because <c><i>timeline</i></c> was <c><i>NULL</i></c>.
RmtErrorCode RmtDataTimelineCreateHistogram(const RmtDataTimeline*    timeline,
                                            RmtJobQueue*              job_queue,
                                            int32_t                   bucket_count,
                                            uint64_t                  bucket_width_in_rmt_cycles,
                                            uint64_t                  start_timestamp,
                                            uint64_t                  end_timestamp,
                                            RmtDataTimelineHistogram* out_timeline_histogram);

/// Destroy a <c><i>RmtDataTimelineHistogram</i></c>.
///
/// @param [in,out]     timeline_histogram                   A pointer to a <c><i>RmtDataTimelineHistogram</i></c> structure to destroy.
///
/// @retval
/// kRmtOk                                          The operation completed successfully.
/// @retval
/// kRmtErrorInvalidPointer                         The operation failed because <c><i>timelineHistogram</i></c> was <c><i>NULL</i></c>.
RmtErrorCode RmtDataTimelineHistogramDestroy(RmtDataTimelineHistogram* timeline_histogram);

/// Get the value at a specific bucket.
///
/// @param [in]         timeline_histogram                  A pointer to a <c><i>RmtDataTimelineHistogram</i></c> structure.
/// @param [in]         bucket_index                        The index of the bucket to access.
/// @param [in]         bucket_group_index                  The index of the item in the bucket. Depends on the grouping mode.
///
/// @retval
/// The value of the item at the specified location in the data set.
int64_t RmtDataTimelineHistogramGetValue(RmtDataTimelineHistogram* timeline_histogram, int32_t bucket_index, int32_t bucket_group_index);

/// Get the index at a specific bucket.
///
/// @param [in]         timeline_histogram                  A pointer to a <c><i>RmtDataTimelineHistogram</i></c> structure.
/// @param [in]         bucket_index                        The index of the bucket to access.
/// @param [in]         bucket_group_index                  The index of the item in the bucket. Depends on the grouping mode.
///
/// @retval
/// The index of the item at the specified location in the data set.
int32_t RmtDataTimelineHistogramGetIndex(RmtDataTimelineHistogram* timeline_histogram, int32_t bucket_index, int32_t bucket_group_index);

#ifdef __cplusplus
}
#endif  // #ifdef __cplusplus
#endif  // #ifndef RMV_BACKEND_RMT_DATA_TIMELINE_H_
